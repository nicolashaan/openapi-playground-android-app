/**
 * Twitter API v2
 *
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.42
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException

import org.openapitools.client.models.Error
import org.openapitools.client.models.GenericMultipleUsersLookupResponse
import org.openapitools.client.models.InlineObject
import org.openapitools.client.models.InlineObject1
import org.openapitools.client.models.InlineObject2
import org.openapitools.client.models.ListLookupMultipleUsersLookupResponse
import org.openapitools.client.models.MultiUserLookupResponse
import org.openapitools.client.models.Problem
import org.openapitools.client.models.SingleUserLookupResponse
import org.openapitools.client.models.UsersBlockingMutationResponse
import org.openapitools.client.models.UsersFollowingCreateResponse
import org.openapitools.client.models.UsersFollowingDeleteResponse
import org.openapitools.client.models.UsersFollowingLookupResponse
import org.openapitools.client.models.UsersMutingMutationResponse

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class UsersApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.twitter.com")
        }
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findMyUser(val value: kotlin.String) {
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findMyUser(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "text") text("text"),
         @Json(name = "author_id") authorId("author_id"),
         @Json(name = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @Json(name = "referenced_tweets") referencedTweets("referenced_tweets"),
         @Json(name = "attachments") attachments("attachments"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "geo") geo("geo"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         @Json(name = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @Json(name = "source") source("source"),
         @Json(name = "lang") lang("lang"),
         @Json(name = "context_annotations") contextAnnotations("context_annotations"),
         @Json(name = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @Json(name = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @Json(name = "organic_metrics") organicMetrics("organic_metrics"),
         @Json(name = "conversation_id") conversationId("conversation_id"),
         @Json(name = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findMyUser(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "name") name("name"),
         @Json(name = "username") username("username"),
         @Json(name = "protected") `protected`("protected"),
         @Json(name = "verified") verified("verified"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "profile_image_url") profileImageUrl("profile_image_url"),
         @Json(name = "location") location("location"),
         @Json(name = "url") url("url"),
         @Json(name = "description") description("description"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup me
    * This endpoint returns information about the requesting user.
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return SingleUserLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findMyUser(expansions: kotlin.collections.List<Expansions_findMyUser>?, tweetFields: kotlin.collections.List<TweetFields_findMyUser>?, userFields: kotlin.collections.List<UserFields_findMyUser>?) : SingleUserLookupResponse {
        val localVarResponse = findMyUserWithHttpInfo(expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SingleUserLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup me
    * This endpoint returns information about the requesting user.
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<SingleUserLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findMyUserWithHttpInfo(expansions: kotlin.collections.List<Expansions_findMyUser>?, tweetFields: kotlin.collections.List<TweetFields_findMyUser>?, userFields: kotlin.collections.List<UserFields_findMyUser>?) : ApiResponse<SingleUserLookupResponse?> {
        val localVariableConfig = findMyUserRequestConfig(expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, SingleUserLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findMyUser
    *
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findMyUserRequestConfig(expansions: kotlin.collections.List<Expansions_findMyUser>?, tweetFields: kotlin.collections.List<TweetFields_findMyUser>?, userFields: kotlin.collections.List<UserFields_findMyUser>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findUserById(val value: kotlin.String) {
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findUserById(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "text") text("text"),
         @Json(name = "author_id") authorId("author_id"),
         @Json(name = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @Json(name = "referenced_tweets") referencedTweets("referenced_tweets"),
         @Json(name = "attachments") attachments("attachments"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "geo") geo("geo"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         @Json(name = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @Json(name = "source") source("source"),
         @Json(name = "lang") lang("lang"),
         @Json(name = "context_annotations") contextAnnotations("context_annotations"),
         @Json(name = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @Json(name = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @Json(name = "organic_metrics") organicMetrics("organic_metrics"),
         @Json(name = "conversation_id") conversationId("conversation_id"),
         @Json(name = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findUserById(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "name") name("name"),
         @Json(name = "username") username("username"),
         @Json(name = "protected") `protected`("protected"),
         @Json(name = "verified") verified("verified"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "profile_image_url") profileImageUrl("profile_image_url"),
         @Json(name = "location") location("location"),
         @Json(name = "url") url("url"),
         @Json(name = "description") description("description"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup by ID
    * This endpoint returns information about a user. Specify user by ID.
    * @param id Required. A User ID. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return SingleUserLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findUserById(id: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserById>?, tweetFields: kotlin.collections.List<TweetFields_findUserById>?, userFields: kotlin.collections.List<UserFields_findUserById>?) : SingleUserLookupResponse {
        val localVarResponse = findUserByIdWithHttpInfo(id = id, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SingleUserLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup by ID
    * This endpoint returns information about a user. Specify user by ID.
    * @param id Required. A User ID. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<SingleUserLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findUserByIdWithHttpInfo(id: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserById>?, tweetFields: kotlin.collections.List<TweetFields_findUserById>?, userFields: kotlin.collections.List<UserFields_findUserById>?) : ApiResponse<SingleUserLookupResponse?> {
        val localVariableConfig = findUserByIdRequestConfig(id = id, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, SingleUserLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findUserById
    *
    * @param id Required. A User ID. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findUserByIdRequestConfig(id: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserById>?, tweetFields: kotlin.collections.List<TweetFields_findUserById>?, userFields: kotlin.collections.List<UserFields_findUserById>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findUserByUsername(val value: kotlin.String) {
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findUserByUsername(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "text") text("text"),
         @Json(name = "author_id") authorId("author_id"),
         @Json(name = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @Json(name = "referenced_tweets") referencedTweets("referenced_tweets"),
         @Json(name = "attachments") attachments("attachments"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "geo") geo("geo"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         @Json(name = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @Json(name = "source") source("source"),
         @Json(name = "lang") lang("lang"),
         @Json(name = "context_annotations") contextAnnotations("context_annotations"),
         @Json(name = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @Json(name = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @Json(name = "organic_metrics") organicMetrics("organic_metrics"),
         @Json(name = "conversation_id") conversationId("conversation_id"),
         @Json(name = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findUserByUsername(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "name") name("name"),
         @Json(name = "username") username("username"),
         @Json(name = "protected") `protected`("protected"),
         @Json(name = "verified") verified("verified"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "profile_image_url") profileImageUrl("profile_image_url"),
         @Json(name = "location") location("location"),
         @Json(name = "url") url("url"),
         @Json(name = "description") description("description"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup by username
    * This endpoint returns information about a user. Specify user by username.
    * @param username Required. A username. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return SingleUserLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findUserByUsername(username: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUserByUsername>?, userFields: kotlin.collections.List<UserFields_findUserByUsername>?) : SingleUserLookupResponse {
        val localVarResponse = findUserByUsernameWithHttpInfo(username = username, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SingleUserLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup by username
    * This endpoint returns information about a user. Specify user by username.
    * @param username Required. A username. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<SingleUserLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findUserByUsernameWithHttpInfo(username: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUserByUsername>?, userFields: kotlin.collections.List<UserFields_findUserByUsername>?) : ApiResponse<SingleUserLookupResponse?> {
        val localVariableConfig = findUserByUsernameRequestConfig(username = username, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, SingleUserLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findUserByUsername
    *
    * @param username Required. A username. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findUserByUsernameRequestConfig(username: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUserByUsername>?, userFields: kotlin.collections.List<UserFields_findUserByUsername>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/by/username/{username}".replace("{"+"username"+"}", "$username"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findUsersById(val value: kotlin.String) {
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findUsersById(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "text") text("text"),
         @Json(name = "author_id") authorId("author_id"),
         @Json(name = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @Json(name = "referenced_tweets") referencedTweets("referenced_tweets"),
         @Json(name = "attachments") attachments("attachments"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "geo") geo("geo"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         @Json(name = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @Json(name = "source") source("source"),
         @Json(name = "lang") lang("lang"),
         @Json(name = "context_annotations") contextAnnotations("context_annotations"),
         @Json(name = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @Json(name = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @Json(name = "organic_metrics") organicMetrics("organic_metrics"),
         @Json(name = "conversation_id") conversationId("conversation_id"),
         @Json(name = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findUsersById(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "name") name("name"),
         @Json(name = "username") username("username"),
         @Json(name = "protected") `protected`("protected"),
         @Json(name = "verified") verified("verified"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "profile_image_url") profileImageUrl("profile_image_url"),
         @Json(name = "location") location("location"),
         @Json(name = "url") url("url"),
         @Json(name = "description") description("description"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup by IDs
    * This endpoint returns information about users. Specify users by their ID.
    * @param ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return MultiUserLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findUsersById(ids: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersById>?, tweetFields: kotlin.collections.List<TweetFields_findUsersById>?, userFields: kotlin.collections.List<UserFields_findUsersById>?) : MultiUserLookupResponse {
        val localVarResponse = findUsersByIdWithHttpInfo(ids = ids, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MultiUserLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup by IDs
    * This endpoint returns information about users. Specify users by their ID.
    * @param ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<MultiUserLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findUsersByIdWithHttpInfo(ids: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersById>?, tweetFields: kotlin.collections.List<TweetFields_findUsersById>?, userFields: kotlin.collections.List<UserFields_findUsersById>?) : ApiResponse<MultiUserLookupResponse?> {
        val localVariableConfig = findUsersByIdRequestConfig(ids = ids, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, MultiUserLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findUsersById
    *
    * @param ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findUsersByIdRequestConfig(ids: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersById>?, tweetFields: kotlin.collections.List<TweetFields_findUsersById>?, userFields: kotlin.collections.List<UserFields_findUsersById>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("ids", toMultiValue(ids.toList(), "csv"))
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findUsersByUsername(val value: kotlin.String) {
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findUsersByUsername(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "text") text("text"),
         @Json(name = "author_id") authorId("author_id"),
         @Json(name = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @Json(name = "referenced_tweets") referencedTweets("referenced_tweets"),
         @Json(name = "attachments") attachments("attachments"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "geo") geo("geo"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         @Json(name = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @Json(name = "source") source("source"),
         @Json(name = "lang") lang("lang"),
         @Json(name = "context_annotations") contextAnnotations("context_annotations"),
         @Json(name = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @Json(name = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @Json(name = "organic_metrics") organicMetrics("organic_metrics"),
         @Json(name = "conversation_id") conversationId("conversation_id"),
         @Json(name = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findUsersByUsername(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "name") name("name"),
         @Json(name = "username") username("username"),
         @Json(name = "protected") `protected`("protected"),
         @Json(name = "verified") verified("verified"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "profile_image_url") profileImageUrl("profile_image_url"),
         @Json(name = "location") location("location"),
         @Json(name = "url") url("url"),
         @Json(name = "description") description("description"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup by usernames
    * This endpoint returns information about users. Specify users by their username.
    * @param usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return MultiUserLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findUsersByUsername(usernames: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUsersByUsername>?, userFields: kotlin.collections.List<UserFields_findUsersByUsername>?) : MultiUserLookupResponse {
        val localVarResponse = findUsersByUsernameWithHttpInfo(usernames = usernames, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MultiUserLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup by usernames
    * This endpoint returns information about users. Specify users by their username.
    * @param usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<MultiUserLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findUsersByUsernameWithHttpInfo(usernames: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUsersByUsername>?, userFields: kotlin.collections.List<UserFields_findUsersByUsername>?) : ApiResponse<MultiUserLookupResponse?> {
        val localVariableConfig = findUsersByUsernameRequestConfig(usernames = usernames, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, MultiUserLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findUsersByUsername
    *
    * @param usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findUsersByUsernameRequestConfig(usernames: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUsersByUsername>?, userFields: kotlin.collections.List<UserFields_findUsersByUsername>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("usernames", toMultiValue(usernames.toList(), "csv"))
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/by",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_listGetFollowers(val value: kotlin.String) {
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_listGetFollowers(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "text") text("text"),
         @Json(name = "author_id") authorId("author_id"),
         @Json(name = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @Json(name = "referenced_tweets") referencedTweets("referenced_tweets"),
         @Json(name = "attachments") attachments("attachments"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "geo") geo("geo"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         @Json(name = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @Json(name = "source") source("source"),
         @Json(name = "lang") lang("lang"),
         @Json(name = "context_annotations") contextAnnotations("context_annotations"),
         @Json(name = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @Json(name = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @Json(name = "organic_metrics") organicMetrics("organic_metrics"),
         @Json(name = "conversation_id") conversationId("conversation_id"),
         @Json(name = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_listGetFollowers(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "name") name("name"),
         @Json(name = "username") username("username"),
         @Json(name = "protected") `protected`("protected"),
         @Json(name = "verified") verified("verified"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "profile_image_url") profileImageUrl("profile_image_url"),
         @Json(name = "location") location("location"),
         @Json(name = "url") url("url"),
         @Json(name = "description") description("description"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * Returns user objects that follow a List by the provided List ID
    * Returns a list of users that follow a List by the provided List ID
    * @param id The ID of the List for which to return followers 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ListLookupMultipleUsersLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listGetFollowers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetFollowers>?, tweetFields: kotlin.collections.List<TweetFields_listGetFollowers>?, userFields: kotlin.collections.List<UserFields_listGetFollowers>?) : ListLookupMultipleUsersLookupResponse {
        val localVarResponse = listGetFollowersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListLookupMultipleUsersLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that follow a List by the provided List ID
    * Returns a list of users that follow a List by the provided List ID
    * @param id The ID of the List for which to return followers 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<ListLookupMultipleUsersLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listGetFollowersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetFollowers>?, tweetFields: kotlin.collections.List<TweetFields_listGetFollowers>?, userFields: kotlin.collections.List<UserFields_listGetFollowers>?) : ApiResponse<ListLookupMultipleUsersLookupResponse?> {
        val localVariableConfig = listGetFollowersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, ListLookupMultipleUsersLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listGetFollowers
    *
    * @param id The ID of the List for which to return followers 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun listGetFollowersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetFollowers>?, tweetFields: kotlin.collections.List<TweetFields_listGetFollowers>?, userFields: kotlin.collections.List<UserFields_listGetFollowers>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/lists/{id}/followers".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_listGetMembers(val value: kotlin.String) {
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_listGetMembers(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "text") text("text"),
         @Json(name = "author_id") authorId("author_id"),
         @Json(name = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @Json(name = "referenced_tweets") referencedTweets("referenced_tweets"),
         @Json(name = "attachments") attachments("attachments"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "geo") geo("geo"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         @Json(name = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @Json(name = "source") source("source"),
         @Json(name = "lang") lang("lang"),
         @Json(name = "context_annotations") contextAnnotations("context_annotations"),
         @Json(name = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @Json(name = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @Json(name = "organic_metrics") organicMetrics("organic_metrics"),
         @Json(name = "conversation_id") conversationId("conversation_id"),
         @Json(name = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_listGetMembers(val value: kotlin.String) {
         @Json(name = "id") id("id"),
         @Json(name = "created_at") createdAt("created_at"),
         @Json(name = "name") name("name"),
         @Json(name = "username") username("username"),
         @Json(name = "protected") `protected`("protected"),
         @Json(name = "verified") verified("verified"),
         @Json(name = "withheld") withheld("withheld"),
         @Json(name = "profile_image_url") profileImageUrl("profile_image_url"),
         @Json(name = "location") location("location"),
         @Json(name = "url") url("url"),
         @Json(name = "description") description("description"),
         @Json(name = "entities") entities("entities"),
         @Json(name = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @Json(name = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * Returns user objects that are members of a List by the provided List ID
    * Returns a list of users that are members of a List by the provided List ID
    * @param id The ID of the List for which to return members 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ListLookupMultipleUsersLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listGetMembers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetMembers>?, tweetFields: kotlin.collections.List<TweetFields_listGetMembers>?, userFields: kotlin.collections.List<UserFields_listGetMembers>?) : ListLookupMultipleUsersLookupResponse {
        val localVarResponse = listGetMembersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListLookupMultipleUsersLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that are members of a List by the provided List ID
    * Returns a list of users that are members of a List by the provided List ID
    * @param id The ID of the List for which to return members 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<ListLookupMultipleUsersLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listGetMembersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetMembers>?, tweetFields: kotlin.collections.List<TweetFields_listGetMembers>?, userFields: kotlin.collections.List<UserFields_listGetMembers>?) : ApiResponse<ListLookupMultipleUsersLookupResponse?> {
        val localVariableConfig = listGetMembersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, ListLookupMultipleUsersLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listGetMembers
    *
    * @param id The ID of the List for which to return members 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun listGetMembersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetMembers>?, tweetFields: kotlin.collections.List<TweetFields_listGetMembers>?, userFields: kotlin.collections.List<UserFields_listGetMembers>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/lists/{id}/members".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that have liked the provided Tweet ID
    * Returns a list of users that have liked the provided Tweet ID
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return GenericMultipleUsersLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tweetsIdLikingUsers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponse {
        val localVarResponse = tweetsIdLikingUsersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that have liked the provided Tweet ID
    * Returns a list of users that have liked the provided Tweet ID
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tweetsIdLikingUsersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponse?> {
        val localVariableConfig = tweetsIdLikingUsersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tweetsIdLikingUsers
    *
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return RequestConfig
    */
    fun tweetsIdLikingUsersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/tweets/{id}/liking_users".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that have retweeted the provided Tweet ID
    * Returns a list of users that have retweeted the provided Tweet ID
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return GenericMultipleUsersLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tweetsIdRetweetingUsers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponse {
        val localVarResponse = tweetsIdRetweetingUsersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that have retweeted the provided Tweet ID
    * Returns a list of users that have retweeted the provided Tweet ID
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tweetsIdRetweetingUsersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponse?> {
        val localVariableConfig = tweetsIdRetweetingUsersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tweetsIdRetweetingUsers
    *
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return RequestConfig
    */
    fun tweetsIdRetweetingUsersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/tweets/{id}/retweeted_by".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Block User by User ID
    * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to block the target user 
    * @param inlineObject  (optional)
    * @return UsersBlockingMutationResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdBlock(id: kotlin.String, inlineObject: InlineObject?) : UsersBlockingMutationResponse {
        val localVarResponse = usersIdBlockWithHttpInfo(id = id, inlineObject = inlineObject)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersBlockingMutationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Block User by User ID
    * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to block the target user 
    * @param inlineObject  (optional)
    * @return ApiResponse<UsersBlockingMutationResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdBlockWithHttpInfo(id: kotlin.String, inlineObject: InlineObject?) : ApiResponse<UsersBlockingMutationResponse?> {
        val localVariableConfig = usersIdBlockRequestConfig(id = id, inlineObject = inlineObject)

        return request<InlineObject, UsersBlockingMutationResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdBlock
    *
    * @param id The ID of the user that is requesting to block the target user 
    * @param inlineObject  (optional)
    * @return RequestConfig
    */
    fun usersIdBlockRequestConfig(id: kotlin.String, inlineObject: InlineObject?) : RequestConfig<InlineObject> {
        val localVariableBody = inlineObject
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/users/{id}/blocking".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that are blocked by provided user ID
    * Returns a list of users that are blocked by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return GenericMultipleUsersLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdBlocking(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponse {
        val localVarResponse = usersIdBlockingWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that are blocked by provided user ID
    * Returns a list of users that are blocked by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdBlockingWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponse?> {
        val localVariableConfig = usersIdBlockingRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdBlocking
    *
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return RequestConfig
    */
    fun usersIdBlockingRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}/blocking".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Follow User
    * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to follow the target user 
    * @param inlineObject2  (optional)
    * @return UsersFollowingCreateResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdFollow(id: kotlin.String, inlineObject2: InlineObject2?) : UsersFollowingCreateResponse {
        val localVarResponse = usersIdFollowWithHttpInfo(id = id, inlineObject2 = inlineObject2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersFollowingCreateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Follow User
    * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to follow the target user 
    * @param inlineObject2  (optional)
    * @return ApiResponse<UsersFollowingCreateResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdFollowWithHttpInfo(id: kotlin.String, inlineObject2: InlineObject2?) : ApiResponse<UsersFollowingCreateResponse?> {
        val localVariableConfig = usersIdFollowRequestConfig(id = id, inlineObject2 = inlineObject2)

        return request<InlineObject2, UsersFollowingCreateResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdFollow
    *
    * @param id The ID of the user that is requesting to follow the target user 
    * @param inlineObject2  (optional)
    * @return RequestConfig
    */
    fun usersIdFollowRequestConfig(id: kotlin.String, inlineObject2: InlineObject2?) : RequestConfig<InlineObject2> {
        val localVariableBody = inlineObject2
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/users/{id}/following".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that follow the provided user ID
    * Returns a list of users that follow the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return GenericMultipleUsersLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdFollowers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponse {
        val localVarResponse = usersIdFollowersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that follow the provided user ID
    * Returns a list of users that follow the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdFollowersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponse?> {
        val localVariableConfig = usersIdFollowersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdFollowers
    *
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return RequestConfig
    */
    fun usersIdFollowersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}/followers".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Following by User ID
    * Returns a list of users that are being followed by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return UsersFollowingLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdFollowing(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : UsersFollowingLookupResponse {
        val localVarResponse = usersIdFollowingWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersFollowingLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Following by User ID
    * Returns a list of users that are being followed by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return ApiResponse<UsersFollowingLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdFollowingWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<UsersFollowingLookupResponse?> {
        val localVariableConfig = usersIdFollowingRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, UsersFollowingLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdFollowing
    *
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return RequestConfig
    */
    fun usersIdFollowingRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}/following".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Mute User by User ID
    * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to mute the target user 
    * @param inlineObject1  (optional)
    * @return UsersMutingMutationResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdMute(id: kotlin.String, inlineObject1: InlineObject1?) : UsersMutingMutationResponse {
        val localVarResponse = usersIdMuteWithHttpInfo(id = id, inlineObject1 = inlineObject1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersMutingMutationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Mute User by User ID
    * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to mute the target user 
    * @param inlineObject1  (optional)
    * @return ApiResponse<UsersMutingMutationResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdMuteWithHttpInfo(id: kotlin.String, inlineObject1: InlineObject1?) : ApiResponse<UsersMutingMutationResponse?> {
        val localVariableConfig = usersIdMuteRequestConfig(id = id, inlineObject1 = inlineObject1)

        return request<InlineObject1, UsersMutingMutationResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdMute
    *
    * @param id The ID of the user that is requesting to mute the target user 
    * @param inlineObject1  (optional)
    * @return RequestConfig
    */
    fun usersIdMuteRequestConfig(id: kotlin.String, inlineObject1: InlineObject1?) : RequestConfig<InlineObject1> {
        val localVariableBody = inlineObject1
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/users/{id}/muting".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that are muted by the provided user ID
    * Returns a list of users that are muted by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return GenericMultipleUsersLookupResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdMuting(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponse {
        val localVarResponse = usersIdMutingWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that are muted by the provided user ID
    * Returns a list of users that are muted by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdMutingWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponse?> {
        val localVariableConfig = usersIdMutingRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdMuting
    *
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return RequestConfig
    */
    fun usersIdMutingRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}/muting".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Unblock User by User ID
    * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unblock the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unblock 
    * @return UsersBlockingMutationResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdUnblock(sourceUserId: kotlin.String, targetUserId: kotlin.String) : UsersBlockingMutationResponse {
        val localVarResponse = usersIdUnblockWithHttpInfo(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersBlockingMutationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Unblock User by User ID
    * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unblock the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unblock 
    * @return ApiResponse<UsersBlockingMutationResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdUnblockWithHttpInfo(sourceUserId: kotlin.String, targetUserId: kotlin.String) : ApiResponse<UsersBlockingMutationResponse?> {
        val localVariableConfig = usersIdUnblockRequestConfig(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return request<Unit, UsersBlockingMutationResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdUnblock
    *
    * @param sourceUserId The ID of the user that is requesting to unblock the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unblock 
    * @return RequestConfig
    */
    fun usersIdUnblockRequestConfig(sourceUserId: kotlin.String, targetUserId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/2/users/{source_user_id}/blocking/{target_user_id}".replace("{"+"source_user_id"+"}", "$sourceUserId").replace("{"+"target_user_id"+"}", "$targetUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Unfollow User
    * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unfollow the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unfollow 
    * @return UsersFollowingDeleteResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdUnfollow(sourceUserId: kotlin.String, targetUserId: kotlin.String) : UsersFollowingDeleteResponse {
        val localVarResponse = usersIdUnfollowWithHttpInfo(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersFollowingDeleteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Unfollow User
    * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unfollow the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unfollow 
    * @return ApiResponse<UsersFollowingDeleteResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdUnfollowWithHttpInfo(sourceUserId: kotlin.String, targetUserId: kotlin.String) : ApiResponse<UsersFollowingDeleteResponse?> {
        val localVariableConfig = usersIdUnfollowRequestConfig(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return request<Unit, UsersFollowingDeleteResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdUnfollow
    *
    * @param sourceUserId The ID of the user that is requesting to unfollow the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unfollow 
    * @return RequestConfig
    */
    fun usersIdUnfollowRequestConfig(sourceUserId: kotlin.String, targetUserId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/2/users/{source_user_id}/following/{target_user_id}".replace("{"+"source_user_id"+"}", "$sourceUserId").replace("{"+"target_user_id"+"}", "$targetUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Unmute User by User ID
    * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unmute the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unmute 
    * @return UsersMutingMutationResponse
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdUnmute(sourceUserId: kotlin.String, targetUserId: kotlin.String) : UsersMutingMutationResponse {
        val localVarResponse = usersIdUnmuteWithHttpInfo(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersMutingMutationResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Unmute User by User ID
    * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unmute the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unmute 
    * @return ApiResponse<UsersMutingMutationResponse?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdUnmuteWithHttpInfo(sourceUserId: kotlin.String, targetUserId: kotlin.String) : ApiResponse<UsersMutingMutationResponse?> {
        val localVariableConfig = usersIdUnmuteRequestConfig(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return request<Unit, UsersMutingMutationResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdUnmute
    *
    * @param sourceUserId The ID of the user that is requesting to unmute the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unmute 
    * @return RequestConfig
    */
    fun usersIdUnmuteRequestConfig(sourceUserId: kotlin.String, targetUserId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/2/users/{source_user_id}/muting/{target_user_id}".replace("{"+"source_user_id"+"}", "$sourceUserId").replace("{"+"target_user_id"+"}", "$targetUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
