/**
 * Twitter API v2
 *
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.42
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package fr.haan.open_api_playground_app.data.api

import java.io.IOException

import fr.haan.open_api_playground_app.data.entities.ErrorEntity
import fr.haan.open_api_playground_app.data.entities.GenericMultipleUsersLookupResponseEntity
import fr.haan.open_api_playground_app.data.entities.InlineObject1Entity
import fr.haan.open_api_playground_app.data.entities.InlineObject2Entity
import fr.haan.open_api_playground_app.data.entities.InlineObjectEntity
import fr.haan.open_api_playground_app.data.entities.ListLookupMultipleUsersLookupResponseEntity
import fr.haan.open_api_playground_app.data.entities.MultiUserLookupResponseEntity
import fr.haan.open_api_playground_app.data.entities.ProblemEntity
import fr.haan.open_api_playground_app.data.entities.SingleUserLookupResponseEntity
import fr.haan.open_api_playground_app.data.entities.UsersBlockingMutationResponseEntity
import fr.haan.open_api_playground_app.data.entities.UsersFollowingCreateResponseEntity
import fr.haan.open_api_playground_app.data.entities.UsersFollowingDeleteResponseEntity
import fr.haan.open_api_playground_app.data.entities.UsersFollowingLookupResponseEntity
import fr.haan.open_api_playground_app.data.entities.UsersMutingMutationResponseEntity

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class UsersApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.twitter.com")
        }
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findMyUser(val value: kotlin.String) {
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findMyUser(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "text") text("text"),
         @SerialName(value = "author_id") authorId("author_id"),
         @SerialName(value = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @SerialName(value = "referenced_tweets") referencedTweets("referenced_tweets"),
         @SerialName(value = "attachments") attachments("attachments"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "geo") geo("geo"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         @SerialName(value = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @SerialName(value = "source") source("source"),
         @SerialName(value = "lang") lang("lang"),
         @SerialName(value = "context_annotations") contextAnnotations("context_annotations"),
         @SerialName(value = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @SerialName(value = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @SerialName(value = "organic_metrics") organicMetrics("organic_metrics"),
         @SerialName(value = "conversation_id") conversationId("conversation_id"),
         @SerialName(value = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findMyUser(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "name") name("name"),
         @SerialName(value = "username") username("username"),
         @SerialName(value = "protected") `protected`("protected"),
         @SerialName(value = "verified") verified("verified"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "profile_image_url") profileImageUrl("profile_image_url"),
         @SerialName(value = "location") location("location"),
         @SerialName(value = "url") url("url"),
         @SerialName(value = "description") description("description"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup me
    * This endpoint returns information about the requesting user.
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return SingleUserLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findMyUser(expansions: kotlin.collections.List<Expansions_findMyUser>?, tweetFields: kotlin.collections.List<TweetFields_findMyUser>?, userFields: kotlin.collections.List<UserFields_findMyUser>?) : SingleUserLookupResponseEntity {
        val localVarResponse = findMyUserWithHttpInfo(expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SingleUserLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup me
    * This endpoint returns information about the requesting user.
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<SingleUserLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findMyUserWithHttpInfo(expansions: kotlin.collections.List<Expansions_findMyUser>?, tweetFields: kotlin.collections.List<TweetFields_findMyUser>?, userFields: kotlin.collections.List<UserFields_findMyUser>?) : ApiResponse<SingleUserLookupResponseEntity?> {
        val localVariableConfig = findMyUserRequestConfig(expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, SingleUserLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findMyUser
    *
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findMyUserRequestConfig(expansions: kotlin.collections.List<Expansions_findMyUser>?, tweetFields: kotlin.collections.List<TweetFields_findMyUser>?, userFields: kotlin.collections.List<UserFields_findMyUser>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findUserById(val value: kotlin.String) {
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findUserById(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "text") text("text"),
         @SerialName(value = "author_id") authorId("author_id"),
         @SerialName(value = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @SerialName(value = "referenced_tweets") referencedTweets("referenced_tweets"),
         @SerialName(value = "attachments") attachments("attachments"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "geo") geo("geo"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         @SerialName(value = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @SerialName(value = "source") source("source"),
         @SerialName(value = "lang") lang("lang"),
         @SerialName(value = "context_annotations") contextAnnotations("context_annotations"),
         @SerialName(value = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @SerialName(value = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @SerialName(value = "organic_metrics") organicMetrics("organic_metrics"),
         @SerialName(value = "conversation_id") conversationId("conversation_id"),
         @SerialName(value = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findUserById(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "name") name("name"),
         @SerialName(value = "username") username("username"),
         @SerialName(value = "protected") `protected`("protected"),
         @SerialName(value = "verified") verified("verified"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "profile_image_url") profileImageUrl("profile_image_url"),
         @SerialName(value = "location") location("location"),
         @SerialName(value = "url") url("url"),
         @SerialName(value = "description") description("description"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup by ID
    * This endpoint returns information about a user. Specify user by ID.
    * @param id Required. A User ID. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return SingleUserLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findUserById(id: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserById>?, tweetFields: kotlin.collections.List<TweetFields_findUserById>?, userFields: kotlin.collections.List<UserFields_findUserById>?) : SingleUserLookupResponseEntity {
        val localVarResponse = findUserByIdWithHttpInfo(id = id, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SingleUserLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup by ID
    * This endpoint returns information about a user. Specify user by ID.
    * @param id Required. A User ID. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<SingleUserLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findUserByIdWithHttpInfo(id: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserById>?, tweetFields: kotlin.collections.List<TweetFields_findUserById>?, userFields: kotlin.collections.List<UserFields_findUserById>?) : ApiResponse<SingleUserLookupResponseEntity?> {
        val localVariableConfig = findUserByIdRequestConfig(id = id, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, SingleUserLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findUserById
    *
    * @param id Required. A User ID. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findUserByIdRequestConfig(id: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserById>?, tweetFields: kotlin.collections.List<TweetFields_findUserById>?, userFields: kotlin.collections.List<UserFields_findUserById>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findUserByUsername(val value: kotlin.String) {
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findUserByUsername(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "text") text("text"),
         @SerialName(value = "author_id") authorId("author_id"),
         @SerialName(value = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @SerialName(value = "referenced_tweets") referencedTweets("referenced_tweets"),
         @SerialName(value = "attachments") attachments("attachments"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "geo") geo("geo"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         @SerialName(value = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @SerialName(value = "source") source("source"),
         @SerialName(value = "lang") lang("lang"),
         @SerialName(value = "context_annotations") contextAnnotations("context_annotations"),
         @SerialName(value = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @SerialName(value = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @SerialName(value = "organic_metrics") organicMetrics("organic_metrics"),
         @SerialName(value = "conversation_id") conversationId("conversation_id"),
         @SerialName(value = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findUserByUsername(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "name") name("name"),
         @SerialName(value = "username") username("username"),
         @SerialName(value = "protected") `protected`("protected"),
         @SerialName(value = "verified") verified("verified"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "profile_image_url") profileImageUrl("profile_image_url"),
         @SerialName(value = "location") location("location"),
         @SerialName(value = "url") url("url"),
         @SerialName(value = "description") description("description"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup by username
    * This endpoint returns information about a user. Specify user by username.
    * @param username Required. A username. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return SingleUserLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findUserByUsername(username: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUserByUsername>?, userFields: kotlin.collections.List<UserFields_findUserByUsername>?) : SingleUserLookupResponseEntity {
        val localVarResponse = findUserByUsernameWithHttpInfo(username = username, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SingleUserLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup by username
    * This endpoint returns information about a user. Specify user by username.
    * @param username Required. A username. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<SingleUserLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findUserByUsernameWithHttpInfo(username: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUserByUsername>?, userFields: kotlin.collections.List<UserFields_findUserByUsername>?) : ApiResponse<SingleUserLookupResponseEntity?> {
        val localVariableConfig = findUserByUsernameRequestConfig(username = username, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, SingleUserLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findUserByUsername
    *
    * @param username Required. A username. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findUserByUsernameRequestConfig(username: kotlin.String, expansions: kotlin.collections.List<Expansions_findUserByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUserByUsername>?, userFields: kotlin.collections.List<UserFields_findUserByUsername>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/by/username/{username}".replace("{"+"username"+"}", "$username"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findUsersById(val value: kotlin.String) {
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findUsersById(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "text") text("text"),
         @SerialName(value = "author_id") authorId("author_id"),
         @SerialName(value = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @SerialName(value = "referenced_tweets") referencedTweets("referenced_tweets"),
         @SerialName(value = "attachments") attachments("attachments"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "geo") geo("geo"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         @SerialName(value = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @SerialName(value = "source") source("source"),
         @SerialName(value = "lang") lang("lang"),
         @SerialName(value = "context_annotations") contextAnnotations("context_annotations"),
         @SerialName(value = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @SerialName(value = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @SerialName(value = "organic_metrics") organicMetrics("organic_metrics"),
         @SerialName(value = "conversation_id") conversationId("conversation_id"),
         @SerialName(value = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findUsersById(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "name") name("name"),
         @SerialName(value = "username") username("username"),
         @SerialName(value = "protected") `protected`("protected"),
         @SerialName(value = "verified") verified("verified"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "profile_image_url") profileImageUrl("profile_image_url"),
         @SerialName(value = "location") location("location"),
         @SerialName(value = "url") url("url"),
         @SerialName(value = "description") description("description"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup by IDs
    * This endpoint returns information about users. Specify users by their ID.
    * @param ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return MultiUserLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findUsersById(ids: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersById>?, tweetFields: kotlin.collections.List<TweetFields_findUsersById>?, userFields: kotlin.collections.List<UserFields_findUsersById>?) : MultiUserLookupResponseEntity {
        val localVarResponse = findUsersByIdWithHttpInfo(ids = ids, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MultiUserLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup by IDs
    * This endpoint returns information about users. Specify users by their ID.
    * @param ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<MultiUserLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findUsersByIdWithHttpInfo(ids: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersById>?, tweetFields: kotlin.collections.List<TweetFields_findUsersById>?, userFields: kotlin.collections.List<UserFields_findUsersById>?) : ApiResponse<MultiUserLookupResponseEntity?> {
        val localVariableConfig = findUsersByIdRequestConfig(ids = ids, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, MultiUserLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findUsersById
    *
    * @param ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findUsersByIdRequestConfig(ids: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersById>?, tweetFields: kotlin.collections.List<TweetFields_findUsersById>?, userFields: kotlin.collections.List<UserFields_findUsersById>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("ids", toMultiValue(ids.toList(), "csv"))
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_findUsersByUsername(val value: kotlin.String) {
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_findUsersByUsername(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "text") text("text"),
         @SerialName(value = "author_id") authorId("author_id"),
         @SerialName(value = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @SerialName(value = "referenced_tweets") referencedTweets("referenced_tweets"),
         @SerialName(value = "attachments") attachments("attachments"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "geo") geo("geo"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         @SerialName(value = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @SerialName(value = "source") source("source"),
         @SerialName(value = "lang") lang("lang"),
         @SerialName(value = "context_annotations") contextAnnotations("context_annotations"),
         @SerialName(value = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @SerialName(value = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @SerialName(value = "organic_metrics") organicMetrics("organic_metrics"),
         @SerialName(value = "conversation_id") conversationId("conversation_id"),
         @SerialName(value = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_findUsersByUsername(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "name") name("name"),
         @SerialName(value = "username") username("username"),
         @SerialName(value = "protected") `protected`("protected"),
         @SerialName(value = "verified") verified("verified"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "profile_image_url") profileImageUrl("profile_image_url"),
         @SerialName(value = "location") location("location"),
         @SerialName(value = "url") url("url"),
         @SerialName(value = "description") description("description"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * User lookup by usernames
    * This endpoint returns information about users. Specify users by their username.
    * @param usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return MultiUserLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun findUsersByUsername(usernames: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUsersByUsername>?, userFields: kotlin.collections.List<UserFields_findUsersByUsername>?) : MultiUserLookupResponseEntity {
        val localVarResponse = findUsersByUsernameWithHttpInfo(usernames = usernames, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MultiUserLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * User lookup by usernames
    * This endpoint returns information about users. Specify users by their username.
    * @param usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<MultiUserLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun findUsersByUsernameWithHttpInfo(usernames: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUsersByUsername>?, userFields: kotlin.collections.List<UserFields_findUsersByUsername>?) : ApiResponse<MultiUserLookupResponseEntity?> {
        val localVariableConfig = findUsersByUsernameRequestConfig(usernames = usernames, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, MultiUserLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findUsersByUsername
    *
    * @param usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames. 
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun findUsersByUsernameRequestConfig(usernames: kotlin.collections.List<kotlin.String>, expansions: kotlin.collections.List<Expansions_findUsersByUsername>?, tweetFields: kotlin.collections.List<TweetFields_findUsersByUsername>?, userFields: kotlin.collections.List<UserFields_findUsersByUsername>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("usernames", toMultiValue(usernames.toList(), "csv"))
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/by",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_listGetFollowers(val value: kotlin.String) {
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_listGetFollowers(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "text") text("text"),
         @SerialName(value = "author_id") authorId("author_id"),
         @SerialName(value = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @SerialName(value = "referenced_tweets") referencedTweets("referenced_tweets"),
         @SerialName(value = "attachments") attachments("attachments"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "geo") geo("geo"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         @SerialName(value = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @SerialName(value = "source") source("source"),
         @SerialName(value = "lang") lang("lang"),
         @SerialName(value = "context_annotations") contextAnnotations("context_annotations"),
         @SerialName(value = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @SerialName(value = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @SerialName(value = "organic_metrics") organicMetrics("organic_metrics"),
         @SerialName(value = "conversation_id") conversationId("conversation_id"),
         @SerialName(value = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_listGetFollowers(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "name") name("name"),
         @SerialName(value = "username") username("username"),
         @SerialName(value = "protected") `protected`("protected"),
         @SerialName(value = "verified") verified("verified"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "profile_image_url") profileImageUrl("profile_image_url"),
         @SerialName(value = "location") location("location"),
         @SerialName(value = "url") url("url"),
         @SerialName(value = "description") description("description"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * Returns user objects that follow a List by the provided List ID
    * Returns a list of users that follow a List by the provided List ID
    * @param id The ID of the List for which to return followers 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ListLookupMultipleUsersLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listGetFollowers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetFollowers>?, tweetFields: kotlin.collections.List<TweetFields_listGetFollowers>?, userFields: kotlin.collections.List<UserFields_listGetFollowers>?) : ListLookupMultipleUsersLookupResponseEntity {
        val localVarResponse = listGetFollowersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListLookupMultipleUsersLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that follow a List by the provided List ID
    * Returns a list of users that follow a List by the provided List ID
    * @param id The ID of the List for which to return followers 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<ListLookupMultipleUsersLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listGetFollowersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetFollowers>?, tweetFields: kotlin.collections.List<TweetFields_listGetFollowers>?, userFields: kotlin.collections.List<UserFields_listGetFollowers>?) : ApiResponse<ListLookupMultipleUsersLookupResponseEntity?> {
        val localVariableConfig = listGetFollowersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, ListLookupMultipleUsersLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listGetFollowers
    *
    * @param id The ID of the List for which to return followers 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun listGetFollowersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetFollowers>?, tweetFields: kotlin.collections.List<TweetFields_listGetFollowers>?, userFields: kotlin.collections.List<UserFields_listGetFollowers>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/lists/{id}/followers".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter expansions
     */
     enum class Expansions_listGetMembers(val value: kotlin.String) {
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         ;
     }

    /**
     * enum for parameter tweetFields
     */
     enum class TweetFields_listGetMembers(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "text") text("text"),
         @SerialName(value = "author_id") authorId("author_id"),
         @SerialName(value = "in_reply_to_user_id") inReplyToUserId("in_reply_to_user_id"),
         @SerialName(value = "referenced_tweets") referencedTweets("referenced_tweets"),
         @SerialName(value = "attachments") attachments("attachments"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "geo") geo("geo"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         @SerialName(value = "possibly_sensitive") possiblySensitive("possibly_sensitive"),
         @SerialName(value = "source") source("source"),
         @SerialName(value = "lang") lang("lang"),
         @SerialName(value = "context_annotations") contextAnnotations("context_annotations"),
         @SerialName(value = "non_public_metrics") nonPublicMetrics("non_public_metrics"),
         @SerialName(value = "promoted_metrics") promotedMetrics("promoted_metrics"),
         @SerialName(value = "organic_metrics") organicMetrics("organic_metrics"),
         @SerialName(value = "conversation_id") conversationId("conversation_id"),
         @SerialName(value = "reply_settings") replySettings("reply_settings"),
         ;
     }

    /**
     * enum for parameter userFields
     */
     enum class UserFields_listGetMembers(val value: kotlin.String) {
         @SerialName(value = "id") id("id"),
         @SerialName(value = "created_at") createdAt("created_at"),
         @SerialName(value = "name") name("name"),
         @SerialName(value = "username") username("username"),
         @SerialName(value = "protected") `protected`("protected"),
         @SerialName(value = "verified") verified("verified"),
         @SerialName(value = "withheld") withheld("withheld"),
         @SerialName(value = "profile_image_url") profileImageUrl("profile_image_url"),
         @SerialName(value = "location") location("location"),
         @SerialName(value = "url") url("url"),
         @SerialName(value = "description") description("description"),
         @SerialName(value = "entities") entities("entities"),
         @SerialName(value = "pinned_tweet_id") pinnedTweetId("pinned_tweet_id"),
         @SerialName(value = "public_metrics") publicMetrics("public_metrics"),
         ;
     }

    /**
    * Returns user objects that are members of a List by the provided List ID
    * Returns a list of users that are members of a List by the provided List ID
    * @param id The ID of the List for which to return members 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ListLookupMultipleUsersLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listGetMembers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetMembers>?, tweetFields: kotlin.collections.List<TweetFields_listGetMembers>?, userFields: kotlin.collections.List<UserFields_listGetMembers>?) : ListLookupMultipleUsersLookupResponseEntity {
        val localVarResponse = listGetMembersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListLookupMultipleUsersLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that are members of a List by the provided List ID
    * Returns a list of users that are members of a List by the provided List ID
    * @param id The ID of the List for which to return members 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return ApiResponse<ListLookupMultipleUsersLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listGetMembersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetMembers>?, tweetFields: kotlin.collections.List<TweetFields_listGetMembers>?, userFields: kotlin.collections.List<UserFields_listGetMembers>?) : ApiResponse<ListLookupMultipleUsersLookupResponseEntity?> {
        val localVariableConfig = listGetMembersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken, expansions = expansions, tweetFields = tweetFields, userFields = userFields)

        return request<Unit, ListLookupMultipleUsersLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listGetMembers
    *
    * @param id The ID of the List for which to return members 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get a specified &#39;page&#39; of results. (optional)
    * @param expansions A comma separated list of fields to expand. (optional)
    * @param tweetFields A comma separated list of Tweet fields to display. (optional)
    * @param userFields A comma separated list of User fields to display. (optional)
    * @return RequestConfig
    */
    fun listGetMembersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.Long?, expansions: kotlin.collections.List<Expansions_listGetMembers>?, tweetFields: kotlin.collections.List<TweetFields_listGetMembers>?, userFields: kotlin.collections.List<UserFields_listGetMembers>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
                if (expansions != null) {
                    put("expansions", toMultiValue(expansions.toList(), "csv"))
                }
                if (tweetFields != null) {
                    put("tweet.fields", toMultiValue(tweetFields.toList(), "csv"))
                }
                if (userFields != null) {
                    put("user.fields", toMultiValue(userFields.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/lists/{id}/members".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that have liked the provided Tweet ID
    * Returns a list of users that have liked the provided Tweet ID
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return GenericMultipleUsersLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tweetsIdLikingUsers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponseEntity {
        val localVarResponse = tweetsIdLikingUsersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that have liked the provided Tweet ID
    * Returns a list of users that have liked the provided Tweet ID
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tweetsIdLikingUsersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponseEntity?> {
        val localVariableConfig = tweetsIdLikingUsersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tweetsIdLikingUsers
    *
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return RequestConfig
    */
    fun tweetsIdLikingUsersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/tweets/{id}/liking_users".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that have retweeted the provided Tweet ID
    * Returns a list of users that have retweeted the provided Tweet ID
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return GenericMultipleUsersLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tweetsIdRetweetingUsers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponseEntity {
        val localVarResponse = tweetsIdRetweetingUsersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that have retweeted the provided Tweet ID
    * Returns a list of users that have retweeted the provided Tweet ID
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tweetsIdRetweetingUsersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponseEntity?> {
        val localVariableConfig = tweetsIdRetweetingUsersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation tweetsIdRetweetingUsers
    *
    * @param id The ID of the Tweet for which to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return RequestConfig
    */
    fun tweetsIdRetweetingUsersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/tweets/{id}/retweeted_by".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Block User by User ID
    * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to block the target user 
    * @param inlineObjectEntity  (optional)
    * @return UsersBlockingMutationResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdBlock(id: kotlin.String, inlineObjectEntity: InlineObjectEntity?) : UsersBlockingMutationResponseEntity {
        val localVarResponse = usersIdBlockWithHttpInfo(id = id, inlineObjectEntity = inlineObjectEntity)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersBlockingMutationResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Block User by User ID
    * Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to block the target user 
    * @param inlineObjectEntity  (optional)
    * @return ApiResponse<UsersBlockingMutationResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdBlockWithHttpInfo(id: kotlin.String, inlineObjectEntity: InlineObjectEntity?) : ApiResponse<UsersBlockingMutationResponseEntity?> {
        val localVariableConfig = usersIdBlockRequestConfig(id = id, inlineObjectEntity = inlineObjectEntity)

        return request<InlineObjectEntity, UsersBlockingMutationResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdBlock
    *
    * @param id The ID of the user that is requesting to block the target user 
    * @param inlineObjectEntity  (optional)
    * @return RequestConfig
    */
    fun usersIdBlockRequestConfig(id: kotlin.String, inlineObjectEntity: InlineObjectEntity?) : RequestConfig<InlineObjectEntity> {
        val localVariableBody = inlineObjectEntity
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/users/{id}/blocking".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that are blocked by provided user ID
    * Returns a list of users that are blocked by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return GenericMultipleUsersLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdBlocking(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponseEntity {
        val localVarResponse = usersIdBlockingWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that are blocked by provided user ID
    * Returns a list of users that are blocked by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdBlockingWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponseEntity?> {
        val localVariableConfig = usersIdBlockingRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdBlocking
    *
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return RequestConfig
    */
    fun usersIdBlockingRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}/blocking".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Follow User
    * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to follow the target user 
    * @param inlineObject2Entity  (optional)
    * @return UsersFollowingCreateResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdFollow(id: kotlin.String, inlineObject2Entity: InlineObject2Entity?) : UsersFollowingCreateResponseEntity {
        val localVarResponse = usersIdFollowWithHttpInfo(id = id, inlineObject2Entity = inlineObject2Entity)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersFollowingCreateResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Follow User
    * Causes the user(in the path) to follow, or request to follow for protected users, the target user. The user(in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to follow the target user 
    * @param inlineObject2Entity  (optional)
    * @return ApiResponse<UsersFollowingCreateResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdFollowWithHttpInfo(id: kotlin.String, inlineObject2Entity: InlineObject2Entity?) : ApiResponse<UsersFollowingCreateResponseEntity?> {
        val localVariableConfig = usersIdFollowRequestConfig(id = id, inlineObject2Entity = inlineObject2Entity)

        return request<InlineObject2Entity, UsersFollowingCreateResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdFollow
    *
    * @param id The ID of the user that is requesting to follow the target user 
    * @param inlineObject2Entity  (optional)
    * @return RequestConfig
    */
    fun usersIdFollowRequestConfig(id: kotlin.String, inlineObject2Entity: InlineObject2Entity?) : RequestConfig<InlineObject2Entity> {
        val localVariableBody = inlineObject2Entity
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/users/{id}/following".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that follow the provided user ID
    * Returns a list of users that follow the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return GenericMultipleUsersLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdFollowers(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponseEntity {
        val localVarResponse = usersIdFollowersWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that follow the provided user ID
    * Returns a list of users that follow the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdFollowersWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponseEntity?> {
        val localVariableConfig = usersIdFollowersRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdFollowers
    *
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return RequestConfig
    */
    fun usersIdFollowersRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}/followers".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Following by User ID
    * Returns a list of users that are being followed by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return UsersFollowingLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdFollowing(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : UsersFollowingLookupResponseEntity {
        val localVarResponse = usersIdFollowingWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersFollowingLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Following by User ID
    * Returns a list of users that are being followed by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return ApiResponse<UsersFollowingLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdFollowingWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<UsersFollowingLookupResponseEntity?> {
        val localVariableConfig = usersIdFollowingRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, UsersFollowingLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdFollowing
    *
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional)
    * @param paginationToken This value is populated by passing the &#39;next_token&#39; or &#39;previous_token&#39; returned in a request to paginate through results. (optional)
    * @return RequestConfig
    */
    fun usersIdFollowingRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}/following".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Mute User by User ID
    * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to mute the target user 
    * @param inlineObject1Entity  (optional)
    * @return UsersMutingMutationResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdMute(id: kotlin.String, inlineObject1Entity: InlineObject1Entity?) : UsersMutingMutationResponseEntity {
        val localVarResponse = usersIdMuteWithHttpInfo(id = id, inlineObject1Entity = inlineObject1Entity)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersMutingMutationResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Mute User by User ID
    * Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
    * @param id The ID of the user that is requesting to mute the target user 
    * @param inlineObject1Entity  (optional)
    * @return ApiResponse<UsersMutingMutationResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdMuteWithHttpInfo(id: kotlin.String, inlineObject1Entity: InlineObject1Entity?) : ApiResponse<UsersMutingMutationResponseEntity?> {
        val localVariableConfig = usersIdMuteRequestConfig(id = id, inlineObject1Entity = inlineObject1Entity)

        return request<InlineObject1Entity, UsersMutingMutationResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdMute
    *
    * @param id The ID of the user that is requesting to mute the target user 
    * @param inlineObject1Entity  (optional)
    * @return RequestConfig
    */
    fun usersIdMuteRequestConfig(id: kotlin.String, inlineObject1Entity: InlineObject1Entity?) : RequestConfig<InlineObject1Entity> {
        val localVariableBody = inlineObject1Entity
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/2/users/{id}/muting".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Returns user objects that are muted by the provided user ID
    * Returns a list of users that are muted by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return GenericMultipleUsersLookupResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdMuting(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : GenericMultipleUsersLookupResponseEntity {
        val localVarResponse = usersIdMutingWithHttpInfo(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GenericMultipleUsersLookupResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Returns user objects that are muted by the provided user ID
    * Returns a list of users that are muted by the provided user ID
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return ApiResponse<GenericMultipleUsersLookupResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdMutingWithHttpInfo(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : ApiResponse<GenericMultipleUsersLookupResponseEntity?> {
        val localVariableConfig = usersIdMutingRequestConfig(id = id, maxResults = maxResults, paginationToken = paginationToken)

        return request<Unit, GenericMultipleUsersLookupResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdMuting
    *
    * @param id The ID of the user for whom to return results 
    * @param maxResults The maximum number of results (optional, default to 100)
    * @param paginationToken This parameter is used to get the next &#39;page&#39; of results. (optional)
    * @return RequestConfig
    */
    fun usersIdMutingRequestConfig(id: kotlin.String, maxResults: kotlin.Int?, paginationToken: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (maxResults != null) {
                    put("max_results", listOf(maxResults.toString()))
                }
                if (paginationToken != null) {
                    put("pagination_token", listOf(paginationToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/2/users/{id}/muting".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Unblock User by User ID
    * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unblock the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unblock 
    * @return UsersBlockingMutationResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdUnblock(sourceUserId: kotlin.String, targetUserId: kotlin.String) : UsersBlockingMutationResponseEntity {
        val localVarResponse = usersIdUnblockWithHttpInfo(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersBlockingMutationResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Unblock User by User ID
    * Causes the source user to unblock the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unblock the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unblock 
    * @return ApiResponse<UsersBlockingMutationResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdUnblockWithHttpInfo(sourceUserId: kotlin.String, targetUserId: kotlin.String) : ApiResponse<UsersBlockingMutationResponseEntity?> {
        val localVariableConfig = usersIdUnblockRequestConfig(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return request<Unit, UsersBlockingMutationResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdUnblock
    *
    * @param sourceUserId The ID of the user that is requesting to unblock the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unblock 
    * @return RequestConfig
    */
    fun usersIdUnblockRequestConfig(sourceUserId: kotlin.String, targetUserId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/2/users/{source_user_id}/blocking/{target_user_id}".replace("{"+"source_user_id"+"}", "$sourceUserId").replace("{"+"target_user_id"+"}", "$targetUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Unfollow User
    * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unfollow the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unfollow 
    * @return UsersFollowingDeleteResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdUnfollow(sourceUserId: kotlin.String, targetUserId: kotlin.String) : UsersFollowingDeleteResponseEntity {
        val localVarResponse = usersIdUnfollowWithHttpInfo(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersFollowingDeleteResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Unfollow User
    * Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unfollow the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unfollow 
    * @return ApiResponse<UsersFollowingDeleteResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdUnfollowWithHttpInfo(sourceUserId: kotlin.String, targetUserId: kotlin.String) : ApiResponse<UsersFollowingDeleteResponseEntity?> {
        val localVariableConfig = usersIdUnfollowRequestConfig(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return request<Unit, UsersFollowingDeleteResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdUnfollow
    *
    * @param sourceUserId The ID of the user that is requesting to unfollow the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unfollow 
    * @return RequestConfig
    */
    fun usersIdUnfollowRequestConfig(sourceUserId: kotlin.String, targetUserId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/2/users/{source_user_id}/following/{target_user_id}".replace("{"+"source_user_id"+"}", "$sourceUserId").replace("{"+"target_user_id"+"}", "$targetUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Unmute User by User ID
    * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unmute the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unmute 
    * @return UsersMutingMutationResponseEntity
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdUnmute(sourceUserId: kotlin.String, targetUserId: kotlin.String) : UsersMutingMutationResponseEntity {
        val localVarResponse = usersIdUnmuteWithHttpInfo(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UsersMutingMutationResponseEntity
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Unmute User by User ID
    * Causes the source user to unmute the target user. The source user must match the user context authorizing the request
    * @param sourceUserId The ID of the user that is requesting to unmute the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unmute 
    * @return ApiResponse<UsersMutingMutationResponseEntity?>
    * @throws IllegalStateException If the request is not correctly configured
    * @throws IOException Rethrows the OkHttp execute method exception
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdUnmuteWithHttpInfo(sourceUserId: kotlin.String, targetUserId: kotlin.String) : ApiResponse<UsersMutingMutationResponseEntity?> {
        val localVariableConfig = usersIdUnmuteRequestConfig(sourceUserId = sourceUserId, targetUserId = targetUserId)

        return request<Unit, UsersMutingMutationResponseEntity>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation usersIdUnmute
    *
    * @param sourceUserId The ID of the user that is requesting to unmute the target user 
    * @param targetUserId The ID of the user that the source user is requesting to unmute 
    * @return RequestConfig
    */
    fun usersIdUnmuteRequestConfig(sourceUserId: kotlin.String, targetUserId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, application/problem+json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/2/users/{source_user_id}/muting/{target_user_id}".replace("{"+"source_user_id"+"}", "$sourceUserId").replace("{"+"target_user_id"+"}", "$targetUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
